## `Home`组件

### 配置路由

1. 一个路由对应一个组件，一个组件对应一个页面或是一个可以被复用的结构

2. **`Vue-Router`的使用**

   1. 什么是`Vue-Router`

      1. `Vue-Router`就是`Vue`框架中的一个路径管理器，用来建立地址和组件之间的映射关系，在`Vue`程序中来开发和实现单页面应用
      2. `Vue`中的单页面应用是基于路由和组件的，路由用于设置地址栏地址的，就是使用全局所注册的`router-link`的实现的，和路由匹配的组件会在`router-view`中渲染，地址栏路径只会有一个，渲染的组件就只有一个，因此整个过程中只有一个完整的页面，实现单页面应用。
      3. 那么从哪里可以看出是单页面应用呢？在使用`vue-cli`搭建脚手架时可以看到项目中只有一个`index.html`；还有就是使用`npm run build`打包项目时，生成的`dist`文件中也只有一个`index.html`

   2. `vue-router`的实现原理和两种模式

   3. `Vue-router`中的参数传递

      1. `$route`上有哪些参数

         1. `query,params,path,meta,fullPath,name`

      2. 路由传参可以传哪些参数

         1. `path,name`
            1. 对于这两个属性来说只能说是我们去匹配，而不是传递
         2. `meta`
            1. 可以在这个属性下配置一些该路由下的其它参数，但该属性是在路由配置中写的，也不需要传递
         3. `query,params`
            1. 真正需要传递的是这两个属性的参数

      3. 路由传参可以有哪些方式（修改`$route`中属性的方式）

         1. `router-link`的`to`属性的值直接是一个字符串，把地址，路由参数和查询字符串都拼接在字符串上，如果要使用变量的话就把`to`变成指令，然后使用反引号，可以在里面使用变量
         2. `router-link`的`to`属性的值是一个对象，对象中的属性可以有`query,params,path,name`，会根据`path`或`name`跳转到对应路由

      4. `query`参数

         1. 字符串的方式

            ```js
            <router-link to="/detail?name=张三&age=23">登录</router-link>
            ```

         2. 对象的方式

            ```js
            <router-link :to="{name:'Detail', query: {
              name: '张三',
              age: 23,
            }}"></router-link>
            ```

      5. `params`参数

         1. 对于`params`参数首先需要在路由中进行定义

            ```js
            {
                name: "search",
            	path: "/search/:searchText?",
            	component: Search
            }
            ```

         2. 字符串的方式

            ```js
            <router-link to="/search/hello">搜索</router-link>
            ```

            此时相当于就把`searchText: hello`传入到了路由的`params`对象中了

         3. 对象的方式

            ```js
            <router-link :to="{name:'search', 
            params: {
              searchText: hello,
            }}"></router-link>
            ```

            注意：用对象的方式传递`params`参数时，只能通过命名路由`name`的方式引入而不能使用`path`来引

      5. 组件获取到路由参数的方式有哪些

         1. 上面两种方式都是把值添加到`$route`上，所以跳转之后的组件直接就可以通过访问`$route`来获取到这些参数了`this.$route.query/this.$route.params`

         2. 通过`props`的方式来获取

            1. 在该组件的路由配置中，添加一个`props`函数，参数为`route`，返回一个对象，对象中就是`query`或`params`属性参数

            2. 在组件内部就可以使用`props`方式来获取

               ```js
                 props(route) {
                   return {
                     ...route.params,
                     ...route.query,
                   };
                 }
               ```

               

   4. `router`和`route`的区别

### `swiper`的使用

1. 用了`swiper`中的一个轮播图，现在`swiper`已经更新到第六个版本了，中文文档还没有，但在`GitHub`里面可以找到英文文档，因为在多个地方都使用到了轮播图，所以我在`swiper`的这个基础上封装了一个轮播图组件

2. 使用这个轮播图组件的话需要向组件内传一个数组，这个数组中的每一项都是一个对象，至少需要有`id`和图片地址两个属性

3. 新版本的这个`swiper`并不是一次性就把所有的东西都导入加载进来的，除了基本的`swiper`以外，需要用到什么就解构出来什么，比如说需要用到分页器，前进后退按钮，我就

   ```js
   import Swiper, { Pagination, Navigation} from "swiper";
   ```

   然后相当于使用组件一样`use`方法才能使用

   ```js
   Swiper.use([Pagination, Navigation]);
   ```

4. 在使用的时候有一个重要的点就是传进来的数据有可能是静态的数据，也有可能是需要向服务器请求的动态数据

   1. 对于静态数据来说比较好办，页面挂载完成了，得到有`DOM`元素了之后直接就可以进行`swiper`的初始化，比较容易成功的实现轮播的效果
   2. 但是对于动态数据，挂载轮播图这个组件的时候还没有数据，所以在`mounted`中初始化是没有用的，那就需要使用监视属性来处理，监视数据的变化，如果数据发生了变化就说明请求到数据了，此时再来初始化`swiper`
      1. 这个时候又要注意，有了数据之后页面会被重新渲染，而只有拿到`DOM`元素才能初始化`swiper`，所以这个时候就要使用`$nextTick()`这个函数了，它的参数是一个函数，是异步的，效果就是下一次`DOM`元素更新之后执行，只会执行一次。
      2. 在这个回调中初始化`swiper`就有效果了

5. 还有一个问题就是多个轮播图都是复用的这个组件，那么在每一次初始化`swiper`的时候就不能搞错了，不然的话就会有问题，解决方式就是在`swiper-container`身上加一个`ref='swiper'`

   ```js
   <div class="swiper-container" ref="swiper"></div>
   ```

   然后初始化`swiper`时指定`ref`而不是使用类名的方式

   ```js
   new Swiper(this.$refs.swiper, {})
   ```

### 优化三级分类列表

1. 每一个分类项都可以点击，实现的方式可以有

   1. 给每一个分类项都加上`router-link`，点击之后跳转
   2. 给每一个分类项都绑定点击事件，事件函数中使用编程式导航来跳转
   3. 上面这两种方式都会给代码造成很大的冗余，非常的不必要，最好的方法就是使用事件委托

2. 事件委托就是把对子元素的点击委托给父元素，每一个子元素被点击，父元素的点击事件也都会被触发，这样就可以把这所有的点击都委托到父元素上，只需要绑定一个点击事件就能实现

3. 我要实现的需求是我点击跳转的时候还需要传入`query`参数，其中`categoryName`表示所选项的名称，`category1Id`表示所选项是第几级的，这些数据都在返回回来的数据对象中，我事件委托的时候只能通过`e.target`得到我所点击的那个元素对象，不能得到这个项的一些数据。这个时候就可以在渲染的时候给元素设置自定义属性，比如一级分类的

   ```js
   <a
     :data-categoryName="category.categoryName"
     :data-categoryId="category.categoryId"
     :data-categoryType="1"
     >{{ category.categoryName }}</a
   >
   ```

   我在事件委托函数中就可以通过

   ```js
   const { categoryname, categoryid, categorytype } = e.target.dataset;
   ```

   来得到这些数据（要注意`dataset`得到的都是小写的）

4. 这里是使用编程式导航来跳转的，得到这些数据之后就可以通过`query`传参方式把数据放到`query`中

   ```js
         const location = {
           name: "search",
           query: {
             categoryName: categoryname,
             [`category${categorytype}Id`]: categoryid,
           },
         };
   ```

   然后使用编程式导航进行跳转

   ```js
   this.$router.replace(location);
   ```

### `nprogress`的使用

1. 作用就是显示请求进度条

2. 既然是请求的进度条，那就得需要在请求中使用，在项目中在使用请求`api`前时对请求做了处理的，也就是处理了请求拦截器和响应拦截器，进度条的使用就是在请求和响应拦截器中引入的

3. 用法很简单，就是下包导包

   ```js
   npm install --save nprogress
   import NProgress from "nprogress";
   ```

   这里需要注意的是同时需要把样式也导进来

   ```js
   import "nprogress/nprogress.css";
   ```

4. 在哪里开始就在哪里调用

   ```js
   NProgress.start();
   ```

   在项目中就是在请求成功的回调中使用

   在哪里结束就在哪里调用

   ```js
   NProgress.done();
   ```

   这里要注意的是在响应的成功和失败回调中都要使用

### `mockjs`的使用

1. 作用就是用来模拟数据，当后端没有现成的数据时，我可以通过这个库生成一些数据来渲染到页面上

2. 使用的时候就相当于搭建了一个`mockServer.js`的服务器，然后我页面中来请求你这个`mockServer.js`服务器中的数据，这个服务器中的数据就是使用`mock`中的一些函数来随机生成的，我再拿到这个数据去渲染

3. `mockServer.js`服务器中需要导入`Mock`这个库

   ```js
   import Mock from "mockjs";
   ```

   然后调用`Mock.mock()`方法来处理路由

   ```js
   Mock.mock("/mock/banner", "get", {
       code: 200,
       "data|4": banner,
   });
   ```

   当请求`/mock/banner`时就能获取到这个路由中的数据

   ```js
   export const reqGetMockBanner = () => {
     return mockRequest({
       method: "GET",
       url: "/mock/banner",
     });
   };
   ```

4. 需要注意的点有

   1. `mockServer.js`需要导入到`main.js`中，相当于开启了这个服务器
   2. 还有就是`mock`中的一些语法

## `Search`组件

### 搜索功能

1. 在这个组件中主要是根据所选的来进行数据的渲染，这就要意识到请求参数的重要性以及各个请求参数分别有什么作用了，我每一次的点击其实都是改变了某一个请求参数并进行了请求，然后后台给我返回回来了此时这些参数下的数据，我拿到这些数据来渲染就行了

### 封装一个分页器组件

1. 封装的时候首先就得考虑我将来会要怎么用，我肯定是要显示一个个的按钮的，按钮的话有：上一页，每一个页码，下一页，共多少条

2. 对于共多少条数据这个按钮，那我就需要从外面传进来共有多少条数据了，从父组件传进来需要接收；而且显示的按钮数量是有限的，所以就需要你告诉我每一页该显示多少条数据，才能计算出来我最多能显示多少按钮；但我还需要你告诉我我要显示多少个按钮我才能知道怎么显示，所以这个显示多少个按钮的数据也需要传进来

   ```js
   props: {
       // 总共的数据量
       total: {
         type: Number,
         defalut: 0,
       },
       // 每页的数据量
       pageSize: {
         type: Number,
         default: 10,
       },
       pagerCount: {
         /*
           每一页的按钮一定是奇数，所以需要进行校验
               要大于等于5且小于等于21的奇数
         */
         type: Number,
         default: 7,
         validator(val) {
           return val >= 5 && val <= 21 && val % 2 === 1;
         },
       },
       /* 
           后续还可以选择去哪一页，所以真正的当前页应该是响应式的
       */
       currentPage: {
         type: Number,
         default: 1,
       },
     },
   ```

3. 对于上一页，下一页这两个按钮，我只需要在每次点击的时候修改以下当前页就好了

4. 重点就是每一个页码按钮，我显示数据就是高亮的页码页的数据，数据显示是比较好显示，定义当前页码的监视属性，只要当前页码变了，就需要触发父组件的方法，把页码传进去进行数据请求就可以，难点就在于如何显示这些按钮，这里就存在好几种情况了

   1. 你让我显示的按钮数量比我能显示的按钮数量多
      1. 这种情况下就直接显示所有能显示的按钮
      2. 两边都没有省略号
   2. 你让我显示的按钮数量和我刚好能显示的数量一样多
      1. 这种情况页直接显示所有能显示的按钮
      2. 两边都没有省略号
   3. 你让我显示的按钮数量比我能显示的数量少
      1. 两边都能出现省略号
      2. 只有一边能出现省略号
      3. 这就要计算中间部分的开始和结束的坐标了
         1. 根据当前页和你让我显示的按钮数量来得到当前页按钮前面显示到哪里，后面显示到哪里
         2. 拿到开始和结束坐标就可以去遍历生成按钮了
            1. 第一个按钮和最后一个按钮不是遍历生成的，这个时候就需要定义计算属性，计算需要遍历生成的按钮数量
            2. 第一个按钮后面和最后一个按钮前面是有省略号的，这个省略号要根据开始位置和结束位置来确定显示隐藏
            3. `v-for`遍历生成时，`expression`不一定要是一个数组，也可以是一个数，每一项的值就是从1开始逐渐递增
               1. 每一个显示出来的按钮的页码就是根据当前页页码来确定的
            4. 使用对象的方式给每一个按钮添加样式，选中时高亮显示

## `Detail`组件

### 实现了一个放大镜的效果（效果）

1. 类似于拖拽的思想，我鼠标放入到区域内时生成一个蒙版，鼠标的位置确定蒙版的定位，大图的定位看似由蒙版的定位确定，但本质上来说还是由鼠标的定位确定

2. 有几点比较重要的

   1. 当蒙版没有任何一边碰到区域边缘时，鼠标一直都处于蒙版中心的位置

      1. 鼠标会有一个位置的坐标

         1. `e.offsetX`：鼠标 到 事件发生的目标元素 的内填充边在x轴方向上的偏移量

      2. 蒙版是绝对定位的，这样的话就可以根据鼠标的位置来确定蒙版的定位从而实现鼠标处于蒙版中心

         1. 设置蒙版定位就是通过`ref`拿到蒙版这个元素对象，然后通过`style`属性来设置

            ```js
            this.$refs.mask.style.left = x + "px";
            this.$refs.mask.style.top = y + "px";
            ```

         2. 同样使用`ref`拿到大图的元素对象，然后确定大图的定位

            ```js
            this.$refs.bigImg.style.left = -2 * x + "px";
            this.$refs.bigImg.style.top = -2 * y + "px";
            ```

            

   2. 当蒙版的某一边和边缘接触了，此时需要设置临界值不让蒙版滑出区域，所以需要进行判断

### 加入购物车（功能）

1. 这里有属性的选择和数量的选择，被选中的属性和数量数据需要在点击购物车之后渲染到后面一个组件上
   1. 对于属性我是将数据收集放到`vuex`中进行管理，选择属性时除了要收集数据还要高亮显示被选中的属性。对于高亮显示只是在同一个属性栏下面高亮一个，其它都不高亮，所以我在每一次点击的时候是需要遍历属性所在的那个属性栏中的所有，先把所有都不高亮，然后然被选中的那个高亮，这样就能实现想要的效果了。
   2. 对于数量，我是通过`query`传参的方式来在下一个组件渲染时使用的。数量可以增减，也可以直接在文本框中输入数字，那在这里需要考虑
      1. 通过点击递增递减，我需要给一个上下限，在这里我下限为1，而且在如果手速过快时，还有可能会出现负数，那我解决的方式就是
         1. 首先，当数量等于1的时候，我就将按钮禁用
         2. 其次对于文本框的值进行条件选择，如果数量小于1时，令其等于1；否则就直接等于商品自己的数量
      2. 通过文本框输入的话，我需要考虑输入的不是数字，如果输入的数字不在上下限之间
         1. 对于如果不是数字的话就需要用到正则校验，就是将不是数字的字符就将该字符剔除
         2. 对于上下限就需要进行判断，然后令其等于上限或下限

## `shopCart`组件

### 结算（功能）

1. 结算前首先要显示渲染所有的购物车数据，这里面是需要对商品进行勾选再进行结算的，那就得先实现这个勾选功能
   1. 我每一次勾选某件商品都是需要发送一个请求的，因为我这里是给每一个`input`绑定了`isChecked`属性的，这个`isChecked`属性是数据对象自己身上的，那我每次点击的时候只要发送请求去改变服务器中的属性值，同时手动修改`vuex`中的数据就能做到更新用户界面了
   2. 对于全选，我是使用的计算属性，每一次计算所有`isChecked`为`true`的元素的数量是否等于总数量，如果相等则为全选，如果不相等则不全选
   3. 每次点击全选按钮的时候本身就会有一个值，然后我遍历发送请求把每一个元素的`isChecked`的值都改为这个值，就可以实现点击的全选与否了
2. 点击结算按钮跳转到新的组件界面，这里面除了数据的渲染之外，有一个需要思考量的就是地址的切换问题，我这里是给遍历渲染的这些地址都绑定了点击事件，类名是绑定到同一个`data`变量中，我每一次点击的时候都修改这个变量值，那每一次就只可能有一个类名是被选中的了





## 支付（功能）

### `QRCode`的使用

1. 我在项目中使用的是微信支付，在这里用到了一个生成二维码的库`QRCode`

   1. 首先是要在组件中引入这个库

      ```js
      import QRCode from "qrcode";
      ```

   2. 然后是调用了`QRCode`上的一个方法`toDataURL`

      ```js
      QRCode.toDataURL(resOfOrder.codeUrl)
        .then((url) => {
          this.$alert(`<img src='${url}'><img>`, "请使用微信扫码支付", {
            confirmButtonText: "我已成功支付",
            cancelButtonText: "支付中遇到了问题",
            showCancelButton: true,
            center: true,
            dangerouslyUseHTMLString: true,
            showClose: false,
          })
            .then(() => {
              this.$message({
                type: "success",
                message: "支付成功",
              });
              // 支付成功跳转到paysuccess
              this.$router.push({
                name: "paysuccess",
              });
            })
            .catch(() => {
              this.$message({
                type: "info",
                message: "请联系前台！",
              });
            });
        })
        .catch((err) => {
          console.error(err);
        });
      ```

      要生成二维码其实就是生成一张图片，所以就需要调接口去生成一个该收款的图片地址，作为参数传入`toDataURL`方法中，方法的结果是得到一个`promise`对象，值就是二维码地址，这样的话就直接可以在`then`中拿到这个二维码图片地址去展示了

      1. 在项目中我是在`this.$alert()`方法中去展示，这个方法的第一个参数可以解析`html`标签，但要在配置项中配置上`dangerouslyUseHTMLString: true`才能实现
      2. 注意`this.$alert()`也是返回一个`promise`

      最终就能实现点击立即支付，弹出二维码的效果了

## 登录（功能）

### `vee-validate`的使用

1. 在输入账号密码的时候进行了验证，在这里我是使用`vee-validate`来实现验证的

2. 在使用前需要导入解构出两个组件

   ```js
   import { ValidationProvider, extend } from "vee-validate";
   ```

   哪个文本框需要被校验，就把这个文本框用`ValidationProvider`包起来

   ```js
     <ValidationProvider rules="phoneLogin" v-slot="{ errors }">
         <span></span>
         <input
           type="text"
           placeholder="邮箱/用户名/手机号"
           v-model="user.phone"
         />
         <i>{{ errors[0] }}</i>
     </ValidationProvider>
   ```

   在这里使用的是作用域插槽，在插槽对象中可以解构处一个`errors`的属性，是一个数组，如果校验失败，就能通过`error[0]`得到失败的信息

   校验或失败信息是写在`extend`函数中的

   ```js
   // 手机号校验
   extend("phoneLogin", {
     // 用于校验的方法
     validate: (value) => {
       if (
         /^1(3\d|4[5-8]|5[0-35-9]|6[567]|7[01345-8]|8\d|9[025-9])\d{8}$/.test(
           value
         )
       ) {
         return true;
       }
     },
     // 校验失败的提示信息
     message: "手机号不规范",
   });
   ```

   第一个参数就是这个校验的校验名，在`ValidationProvider`使用`rules`来指定使用哪个校验

   1. `validate`是用于校验的方法，就是对使用`v-model`收集到的数据进行校验
      1. 注意，校验成功了一定要`return true`，该函数如果没有返回`true`在表示校验失败，那么`error[0]`就能得到这个错误信息了

### `uuid`的使用

1. 登录成功后，服务器是会生成一个`token`来代表当前用户的，那如果没有登录的时候用什么来表示当前用户呢，项目中是需要一个临时`id`来表示未登录状态的，在这里我是使用`uuid`这个库来生成一个临时`id`的

2. 使用的时候是要解构出对应组件的

   ```js
   import { v4 as uuidv4 } from "uuid";
   ```

   我哪里要使用就直接在那里调用这个方法就行了

   ```js
   userTempId = uuidv4();
   ```



## 注册功能

这里主要除了校验之外还有一个比较重要的就是验证码的更新

```js
<img
  ref="code"
  src="http://182.92.128.115/api/user/passport/code"
  alt="code"
  @click="changeCodeImg"
/>
```

这里是一张图片，我每次点击图片需要更新这个验证码，所以我可以直接绑定一个事件，在每次点击事件时重新发送请求就可以了

```js
changeCodeImg() {
  this.$refs.code.src = "http://182.92.128.115/api/user/passport/code";
},
```

## 项目优化

### 图片懒加载

1. 在这里我是使用了`vue-lazyload`来实现图片懒加载的，首先要引入对象

   ```js
   import VueLazyload from "vue-lazyload";
   ```

2. 然后在使用时进行配置

   ```js
   Vue.use(VueLazyload, {
   	// loading: "../assets/imgs/loading.gif", // 不行，不能当做图片解析
   	loading: loading,
   });
   ```

   这里要注意的一点就是`loading`这个属性的值确实需要是一个对象，但是这个图片不能直接用图片地址来引入，而是需要使用引入对象的方式才能生效

   ```js
   import loading from "../assets/imgs/loading.gif";
   ```

### 路由懒加载

在路由配置中把原来的引入方式

```js
import Home from "../views/Home";
```

改成

```js
const Home = () => import(/* webpackChunkName: "Home" */"../views/Home");
```

即可。这里可以在前面给引入的改路由命名，这样在打包后的文件中就能看到对应命名的`js`文件了

### `webpack`优化